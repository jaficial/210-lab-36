Binary Trees: 
There isn't a C++ STL for binary trees, but it uses containers such as std::set, and std::map.
- Binary Trees are implemented using structs/classes
    - each node contains some data and pointers to left and right children
    - implemented to understand optimal time complexities for various operations
- It is a nonlinear linked list, in which each node points to 0, 1, or 2 other nodes
    - each node contains onre or more data fields, along with two pointers
- How it works:
    - The root node (top-most parent node) is a pointer to a child node
    - the child node being pointed to contains a set of data, and two pointers
        - first pointer points to the left child node
        - second poitner points to the right child node
        - They may also point to leaf nodes
            - Leaf nodes are nodes with no children (will point to null)
    - when referring to a node, the node is the set of data


Binary Search Trees: 
- Efficient way to sort through a large sets of data
- Characteristics:
    - the right child node is typically larger than its parent node
    - the left child node is typically smaller than its parent node
    - very efficient at sorting through data due to being able to skip through half of the binary tree at a time
- How to search in a Binary Search Tree:
    - Start at the root node and examine its data
        - if its desired value, search is finished
    - if the desired value is less than the node data, go to the left subtree
    - if the desired value is mroe than the node data, go to the right subtree
        - continue until the desired value is found, or a null pointer is reached
            - if a null pointer is reached this indicates a unsuccessful search
- Inserting a Node:
    - If the node to be inserted is larger than the parent node
        - traverse to the node on the right
        - if the node on the right is null
            - have the parent node point to the new node
        - if the node on the right has a value
            - repeat process until you reach a null
    - If the node to be inserted is smaller than the parent node
        - traverse to the node on the left
        - do process stated above, and repeat if necessary 
- Traversing a Binary Tree: 
    - Inorder: 
        - traverse its left sub tree first
        - process the node's data
        - then traverse its right subtree
        - GOOD FOR:
            - performing a range operation, like a range query
            - Useful if the tree structure needs to be serialized, if later it needs to be reconstructed or stored easily in a file
    - Preorder: 
        - process the node's data
        - traverse its left subtree, then traverse its right subtree
        - GOOD FOR: 
            - creating a copy of the tree
            - also useful if the tree structure needs to be serialized, so it can be reconstructed/stored in a file 
    - Postorder: 
        - for any given node, traverse its left subtree first
        - then traverse the right subtree
        - then process the node's data
        - GOOD FOR:
            - deleting the tree, as you need to delete the children before deleting the node
            - also used in post-fix expressions such as "Reverse Polish Notation"
            - Compilers use postorder traversal to evaluate the correct order of operations in an expression
- Deleting a Node: 
    - If the node to be deleted is a leaf node
        - replace the parent's pointer with a null pointer
        - then delete node
    - If the node has one child node
        - the parent node is adjusted to point to the child of the doomed node
        - the doomed node gets deleted
    - If the doomed node has two children
        - promote one child to replace the parent node 
        - locate the correct position for the other child in the promoted child
